{"ast":null,"code":"import { diffLines } from '../diff/line.js';\nexport function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  let optionsObj;\n  if (!options) {\n    optionsObj = {};\n  } else if (typeof options === 'function') {\n    optionsObj = {\n      callback: options\n    };\n  } else {\n    optionsObj = options;\n  }\n  if (typeof optionsObj.context === 'undefined') {\n    optionsObj.context = 4;\n  }\n  // We copy this into its own variable to placate TypeScript, which thinks\n  // optionsObj.context might be undefined in the callbacks below.\n  const context = optionsObj.context;\n  // @ts-expect-error (runtime check for something that is correctly a static type error)\n  if (optionsObj.newlineIsToken) {\n    throw new Error('newlineIsToken may not be used with patch-generation functions, only with diffing functions');\n  }\n  if (!optionsObj.callback) {\n    return diffLinesResultToPatch(diffLines(oldStr, newStr, optionsObj));\n  } else {\n    const {\n      callback\n    } = optionsObj;\n    diffLines(oldStr, newStr, Object.assign(Object.assign({}, optionsObj), {\n      callback: diff => {\n        const patch = diffLinesResultToPatch(diff);\n        // TypeScript is unhappy without the cast because it does not understand that `patch` may\n        // be undefined here only if `callback` is StructuredPatchCallbackAbortable:\n        callback(patch);\n      }\n    }));\n  }\n  function diffLinesResultToPatch(diff) {\n    // STEP 1: Build up the patch with no \"\\ No newline at end of file\" lines and with the arrays\n    //         of lines containing trailing newline characters. We'll tidy up later...\n    if (!diff) {\n      return;\n    }\n    diff.push({\n      value: '',\n      lines: []\n    }); // Append an empty value to make cleanup easier\n    function contextLines(lines) {\n      return lines.map(function (entry) {\n        return ' ' + entry;\n      });\n    }\n    const hunks = [];\n    let oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n    for (let i = 0; i < diff.length; i++) {\n      const current = diff[i],\n        lines = current.lines || splitLines(current.value);\n      current.lines = lines;\n      if (current.added || current.removed) {\n        // If we have previous context, start with that\n        if (!oldRangeStart) {\n          const prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n          if (prev) {\n            curRange = context > 0 ? contextLines(prev.lines.slice(-context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        }\n        // Output our changes\n        for (const line of lines) {\n          curRange.push((current.added ? '+' : '-') + line);\n        }\n        // Track the updated file position\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= context * 2 && i < diff.length - 2) {\n            // Overlapping\n            for (const line of contextLines(lines)) {\n              curRange.push(line);\n            }\n          } else {\n            // end the range and output\n            const contextSize = Math.min(lines.length, context);\n            for (const line of contextLines(lines.slice(0, contextSize))) {\n              curRange.push(line);\n            }\n            const hunk = {\n              oldStart: oldRangeStart,\n              oldLines: oldLine - oldRangeStart + contextSize,\n              newStart: newRangeStart,\n              newLines: newLine - newRangeStart + contextSize,\n              lines: curRange\n            };\n            hunks.push(hunk);\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    }\n    // Step 2: eliminate the trailing `\\n` from each line of each hunk, and, where needed, add\n    //         \"\\ No newline at end of file\".\n    for (const hunk of hunks) {\n      for (let i = 0; i < hunk.lines.length; i++) {\n        if (hunk.lines[i].endsWith('\\n')) {\n          hunk.lines[i] = hunk.lines[i].slice(0, -1);\n        } else {\n          hunk.lines.splice(i + 1, 0, '\\\\ No newline at end of file');\n          i++; // Skip the line we just added, then continue iterating\n        }\n      }\n    }\n    return {\n      oldFileName: oldFileName,\n      newFileName: newFileName,\n      oldHeader: oldHeader,\n      newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n}\n/**\n * creates a unified diff patch.\n * @param patch either a single structured patch object (as returned by `structuredPatch`) or an array of them (as returned by `parsePatch`)\n */\nexport function formatPatch(patch) {\n  if (Array.isArray(patch)) {\n    return patch.map(formatPatch).join('\\n');\n  }\n  const ret = [];\n  if (patch.oldFileName == patch.newFileName) {\n    ret.push('Index: ' + patch.oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + patch.oldFileName + (typeof patch.oldHeader === 'undefined' ? '' : '\\t' + patch.oldHeader));\n  ret.push('+++ ' + patch.newFileName + (typeof patch.newHeader === 'undefined' ? '' : '\\t' + patch.newHeader));\n  for (let i = 0; i < patch.hunks.length; i++) {\n    const hunk = patch.hunks[i];\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    for (const line of hunk.lines) {\n      ret.push(line);\n    }\n  }\n  return ret.join('\\n') + '\\n';\n}\nexport function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (typeof options === 'function') {\n    options = {\n      callback: options\n    };\n  }\n  if (!(options === null || options === void 0 ? void 0 : options.callback)) {\n    const patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n    if (!patchObj) {\n      return;\n    }\n    return formatPatch(patchObj);\n  } else {\n    const {\n      callback\n    } = options;\n    structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, Object.assign(Object.assign({}, options), {\n      callback: patchObj => {\n        if (!patchObj) {\n          callback(undefined);\n        } else {\n          callback(formatPatch(patchObj));\n        }\n      }\n    }));\n  }\n}\nexport function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n/**\n * Split `text` into an array of lines, including the trailing newline character (where present)\n */\nfunction splitLines(text) {\n  const hasTrailingNl = text.endsWith('\\n');\n  const result = text.split('\\n').map(line => line + '\\n');\n  if (hasTrailingNl) {\n    result.pop();\n  } else {\n    result.push(result.pop().slice(0, -1));\n  }\n  return result;\n}","map":{"version":3,"names":["diffLines","structuredPatch","oldFileName","newFileName","oldStr","newStr","oldHeader","newHeader","options","optionsObj","callback","context","newlineIsToken","Error","diffLinesResultToPatch","Object","assign","diff","patch","push","value","lines","contextLines","map","entry","hunks","oldRangeStart","newRangeStart","curRange","oldLine","newLine","i","length","current","splitLines","added","removed","prev","slice","line","contextSize","Math","min","hunk","oldStart","oldLines","newStart","newLines","endsWith","splice","formatPatch","Array","isArray","join","ret","createTwoFilesPatch","patchObj","undefined","createPatch","fileName","text","hasTrailingNl","result","split","pop"],"sources":["/Users/elias/Documents/Trabajo/Pruebas-del-IMSS/Simulacion/frontend/node_modules/diff/libesm/patch/create.js"],"sourcesContent":["import { diffLines } from '../diff/line.js';\nexport function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    let optionsObj;\n    if (!options) {\n        optionsObj = {};\n    }\n    else if (typeof options === 'function') {\n        optionsObj = { callback: options };\n    }\n    else {\n        optionsObj = options;\n    }\n    if (typeof optionsObj.context === 'undefined') {\n        optionsObj.context = 4;\n    }\n    // We copy this into its own variable to placate TypeScript, which thinks\n    // optionsObj.context might be undefined in the callbacks below.\n    const context = optionsObj.context;\n    // @ts-expect-error (runtime check for something that is correctly a static type error)\n    if (optionsObj.newlineIsToken) {\n        throw new Error('newlineIsToken may not be used with patch-generation functions, only with diffing functions');\n    }\n    if (!optionsObj.callback) {\n        return diffLinesResultToPatch(diffLines(oldStr, newStr, optionsObj));\n    }\n    else {\n        const { callback } = optionsObj;\n        diffLines(oldStr, newStr, Object.assign(Object.assign({}, optionsObj), { callback: (diff) => {\n                const patch = diffLinesResultToPatch(diff);\n                // TypeScript is unhappy without the cast because it does not understand that `patch` may\n                // be undefined here only if `callback` is StructuredPatchCallbackAbortable:\n                callback(patch);\n            } }));\n    }\n    function diffLinesResultToPatch(diff) {\n        // STEP 1: Build up the patch with no \"\\ No newline at end of file\" lines and with the arrays\n        //         of lines containing trailing newline characters. We'll tidy up later...\n        if (!diff) {\n            return;\n        }\n        diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier\n        function contextLines(lines) {\n            return lines.map(function (entry) { return ' ' + entry; });\n        }\n        const hunks = [];\n        let oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;\n        for (let i = 0; i < diff.length; i++) {\n            const current = diff[i], lines = current.lines || splitLines(current.value);\n            current.lines = lines;\n            if (current.added || current.removed) {\n                // If we have previous context, start with that\n                if (!oldRangeStart) {\n                    const prev = diff[i - 1];\n                    oldRangeStart = oldLine;\n                    newRangeStart = newLine;\n                    if (prev) {\n                        curRange = context > 0 ? contextLines(prev.lines.slice(-context)) : [];\n                        oldRangeStart -= curRange.length;\n                        newRangeStart -= curRange.length;\n                    }\n                }\n                // Output our changes\n                for (const line of lines) {\n                    curRange.push((current.added ? '+' : '-') + line);\n                }\n                // Track the updated file position\n                if (current.added) {\n                    newLine += lines.length;\n                }\n                else {\n                    oldLine += lines.length;\n                }\n            }\n            else {\n                // Identical context lines. Track line changes\n                if (oldRangeStart) {\n                    // Close out any changes that have been output (or join overlapping)\n                    if (lines.length <= context * 2 && i < diff.length - 2) {\n                        // Overlapping\n                        for (const line of contextLines(lines)) {\n                            curRange.push(line);\n                        }\n                    }\n                    else {\n                        // end the range and output\n                        const contextSize = Math.min(lines.length, context);\n                        for (const line of contextLines(lines.slice(0, contextSize))) {\n                            curRange.push(line);\n                        }\n                        const hunk = {\n                            oldStart: oldRangeStart,\n                            oldLines: (oldLine - oldRangeStart + contextSize),\n                            newStart: newRangeStart,\n                            newLines: (newLine - newRangeStart + contextSize),\n                            lines: curRange\n                        };\n                        hunks.push(hunk);\n                        oldRangeStart = 0;\n                        newRangeStart = 0;\n                        curRange = [];\n                    }\n                }\n                oldLine += lines.length;\n                newLine += lines.length;\n            }\n        }\n        // Step 2: eliminate the trailing `\\n` from each line of each hunk, and, where needed, add\n        //         \"\\ No newline at end of file\".\n        for (const hunk of hunks) {\n            for (let i = 0; i < hunk.lines.length; i++) {\n                if (hunk.lines[i].endsWith('\\n')) {\n                    hunk.lines[i] = hunk.lines[i].slice(0, -1);\n                }\n                else {\n                    hunk.lines.splice(i + 1, 0, '\\\\ No newline at end of file');\n                    i++; // Skip the line we just added, then continue iterating\n                }\n            }\n        }\n        return {\n            oldFileName: oldFileName, newFileName: newFileName,\n            oldHeader: oldHeader, newHeader: newHeader,\n            hunks: hunks\n        };\n    }\n}\n/**\n * creates a unified diff patch.\n * @param patch either a single structured patch object (as returned by `structuredPatch`) or an array of them (as returned by `parsePatch`)\n */\nexport function formatPatch(patch) {\n    if (Array.isArray(patch)) {\n        return patch.map(formatPatch).join('\\n');\n    }\n    const ret = [];\n    if (patch.oldFileName == patch.newFileName) {\n        ret.push('Index: ' + patch.oldFileName);\n    }\n    ret.push('===================================================================');\n    ret.push('--- ' + patch.oldFileName + (typeof patch.oldHeader === 'undefined' ? '' : '\\t' + patch.oldHeader));\n    ret.push('+++ ' + patch.newFileName + (typeof patch.newHeader === 'undefined' ? '' : '\\t' + patch.newHeader));\n    for (let i = 0; i < patch.hunks.length; i++) {\n        const hunk = patch.hunks[i];\n        // Unified Diff Format quirk: If the chunk size is 0,\n        // the first number is one lower than one would expect.\n        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n        if (hunk.oldLines === 0) {\n            hunk.oldStart -= 1;\n        }\n        if (hunk.newLines === 0) {\n            hunk.newStart -= 1;\n        }\n        ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines\n            + ' +' + hunk.newStart + ',' + hunk.newLines\n            + ' @@');\n        for (const line of hunk.lines) {\n            ret.push(line);\n        }\n    }\n    return ret.join('\\n') + '\\n';\n}\nexport function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (typeof options === 'function') {\n        options = { callback: options };\n    }\n    if (!(options === null || options === void 0 ? void 0 : options.callback)) {\n        const patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n        if (!patchObj) {\n            return;\n        }\n        return formatPatch(patchObj);\n    }\n    else {\n        const { callback } = options;\n        structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, Object.assign(Object.assign({}, options), { callback: patchObj => {\n                if (!patchObj) {\n                    callback(undefined);\n                }\n                else {\n                    callback(formatPatch(patchObj));\n                }\n            } }));\n    }\n}\nexport function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n/**\n * Split `text` into an array of lines, including the trailing newline character (where present)\n */\nfunction splitLines(text) {\n    const hasTrailingNl = text.endsWith('\\n');\n    const result = text.split('\\n').map(line => line + '\\n');\n    if (hasTrailingNl) {\n        result.pop();\n    }\n    else {\n        result.push(result.pop().slice(0, -1));\n    }\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}