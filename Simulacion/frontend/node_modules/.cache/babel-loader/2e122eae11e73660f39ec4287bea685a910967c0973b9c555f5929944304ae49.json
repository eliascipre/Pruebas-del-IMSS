{"ast":null,"code":"// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nexport default function (start, minLine, maxLine) {\n  let wantForward = true,\n    backwardExhausted = false,\n    forwardExhausted = false,\n    localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      }\n      // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n      if (start + localOffset <= maxLine) {\n        return start + localOffset;\n      }\n      forwardExhausted = true;\n    }\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      }\n      // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n      if (minLine <= start - localOffset) {\n        return start - localOffset++;\n      }\n      backwardExhausted = true;\n      return iterator();\n    }\n    // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n    return undefined;\n  };\n}","map":{"version":3,"names":["start","minLine","maxLine","wantForward","backwardExhausted","forwardExhausted","localOffset","iterator","undefined"],"sources":["/home/elias/Documentos/Simulacion/frontend/node_modules/diff/libesm/util/distance-iterator.js"],"sourcesContent":["// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nexport default function (start, minLine, maxLine) {\n    let wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;\n    return function iterator() {\n        if (wantForward && !forwardExhausted) {\n            if (backwardExhausted) {\n                localOffset++;\n            }\n            else {\n                wantForward = false;\n            }\n            // Check if trying to fit beyond text length, and if not, check it fits\n            // after offset location (or desired location on first iteration)\n            if (start + localOffset <= maxLine) {\n                return start + localOffset;\n            }\n            forwardExhausted = true;\n        }\n        if (!backwardExhausted) {\n            if (!forwardExhausted) {\n                wantForward = true;\n            }\n            // Check if trying to fit before text beginning, and if not, check it fits\n            // before offset location\n            if (minLine <= start - localOffset) {\n                return start - localOffset++;\n            }\n            backwardExhausted = true;\n            return iterator();\n        }\n        // We tried to fit hunk before text beginning and beyond text length, then\n        // hunk can't fit on the text. Return undefined\n        return undefined;\n    };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,eAAe,UAAUA,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAE;EAC9C,IAAIC,WAAW,GAAG,IAAI;IAAEC,iBAAiB,GAAG,KAAK;IAAEC,gBAAgB,GAAG,KAAK;IAAEC,WAAW,GAAG,CAAC;EAC5F,OAAO,SAASC,QAAQA,CAAA,EAAG;IACvB,IAAIJ,WAAW,IAAI,CAACE,gBAAgB,EAAE;MAClC,IAAID,iBAAiB,EAAE;QACnBE,WAAW,EAAE;MACjB,CAAC,MACI;QACDH,WAAW,GAAG,KAAK;MACvB;MACA;MACA;MACA,IAAIH,KAAK,GAAGM,WAAW,IAAIJ,OAAO,EAAE;QAChC,OAAOF,KAAK,GAAGM,WAAW;MAC9B;MACAD,gBAAgB,GAAG,IAAI;IAC3B;IACA,IAAI,CAACD,iBAAiB,EAAE;MACpB,IAAI,CAACC,gBAAgB,EAAE;QACnBF,WAAW,GAAG,IAAI;MACtB;MACA;MACA;MACA,IAAIF,OAAO,IAAID,KAAK,GAAGM,WAAW,EAAE;QAChC,OAAON,KAAK,GAAGM,WAAW,EAAE;MAChC;MACAF,iBAAiB,GAAG,IAAI;MACxB,OAAOG,QAAQ,CAAC,CAAC;IACrB;IACA;IACA;IACA,OAAOC,SAAS;EACpB,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}