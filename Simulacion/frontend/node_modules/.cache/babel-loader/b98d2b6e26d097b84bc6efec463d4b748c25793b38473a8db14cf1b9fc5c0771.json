{"ast":null,"code":"export default class Diff {\n  diff(oldStr, newStr) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else if ('callback' in options) {\n      callback = options.callback;\n    }\n    // Allow subclasses to massage the input prior to running\n    const oldString = this.castInput(oldStr, options);\n    const newString = this.castInput(newStr, options);\n    const oldTokens = this.removeEmpty(this.tokenize(oldString, options));\n    const newTokens = this.removeEmpty(this.tokenize(newString, options));\n    return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);\n  }\n  diffWithOptionsObj(oldTokens, newTokens, options, callback) {\n    var _a;\n    const done = value => {\n      value = this.postProcess(value, options);\n      if (callback) {\n        setTimeout(function () {\n          callback(value);\n        }, 0);\n        return undefined;\n      } else {\n        return value;\n      }\n    };\n    const newLen = newTokens.length,\n      oldLen = oldTokens.length;\n    let editLength = 1;\n    let maxEditLength = newLen + oldLen;\n    if (options.maxEditLength != null) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n    const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;\n    const abortAfterTimestamp = Date.now() + maxExecutionTime;\n    const bestPath = [{\n      oldPos: -1,\n      lastComponent: undefined\n    }];\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);\n    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n      // Identity per the equality and tokenizer\n      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));\n    }\n    // Once we hit the right edge of the edit graph on some diagonal k, we can\n    // definitely reach the end of the edit graph in no more than k edits, so\n    // there's no point in considering any moves to diagonal k+1 any more (from\n    // which we're guaranteed to need at least k+1 more edits).\n    // Similarly, once we've reached the bottom of the edit graph, there's no\n    // point considering moves to lower diagonals.\n    // We record this fact by setting minDiagonalToConsider and\n    // maxDiagonalToConsider to some finite value once we've hit the edge of\n    // the edit graph.\n    // This optimization is not faithful to the original algorithm presented in\n    // Myers's paper, which instead pointlessly extends D-paths off the end of\n    // the edit graph - see page 7 of Myers's paper which notes this point\n    // explicitly and illustrates it with a diagram. This has major performance\n    // implications for some common scenarios. For instance, to compute a diff\n    // where the new text simply appends d characters on the end of the\n    // original text of length n, the true Myers algorithm will take O(n+d^2)\n    // time while this optimization needs only O(n+d) time.\n    let minDiagonalToConsider = -Infinity,\n      maxDiagonalToConsider = Infinity;\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    const execEditLength = () => {\n      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n        let basePath;\n        const removePath = bestPath[diagonalPath - 1],\n          addPath = bestPath[diagonalPath + 1];\n        if (removePath) {\n          // No one else is going to attempt to use this value, clear it\n          // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n          bestPath[diagonalPath - 1] = undefined;\n        }\n        let canAdd = false;\n        if (addPath) {\n          // what newPos will be after we do an insertion:\n          const addPathNewPos = addPath.oldPos - diagonalPath;\n          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n        }\n        const canRemove = removePath && removePath.oldPos + 1 < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the old string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {\n          basePath = this.addToPath(addPath, true, false, 0, options);\n        } else {\n          basePath = this.addToPath(removePath, false, true, 1, options);\n        }\n        newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);\n        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // If we have hit the end of both strings, then we are done\n          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;\n        } else {\n          bestPath[diagonalPath] = basePath;\n          if (basePath.oldPos + 1 >= oldLen) {\n            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n          }\n          if (newPos + 1 >= newLen) {\n            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n          }\n        }\n      }\n      editLength++;\n    };\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n            return callback(undefined);\n          }\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n        const ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  }\n  addToPath(path, added, removed, oldPosInc, options) {\n    const last = path.lastComponent;\n    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: last.count + 1,\n          added: added,\n          removed: removed,\n          previousComponent: last.previousComponent\n        }\n      };\n    } else {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: 1,\n          added: added,\n          removed: removed,\n          previousComponent: last\n        }\n      };\n    }\n  }\n  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {\n    const newLen = newTokens.length,\n      oldLen = oldTokens.length;\n    let oldPos = basePath.oldPos,\n      newPos = oldPos - diagonalPath,\n      commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n      if (options.oneChangePerToken) {\n        basePath.lastComponent = {\n          count: 1,\n          previousComponent: basePath.lastComponent,\n          added: false,\n          removed: false\n        };\n      }\n    }\n    if (commonCount && !options.oneChangePerToken) {\n      basePath.lastComponent = {\n        count: commonCount,\n        previousComponent: basePath.lastComponent,\n        added: false,\n        removed: false\n      };\n    }\n    basePath.oldPos = oldPos;\n    return newPos;\n  }\n  equals(left, right, options) {\n    if (options.comparator) {\n      return options.comparator(left, right);\n    } else {\n      return left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  }\n  removeEmpty(array) {\n    const ret = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  castInput(value, options) {\n    return value;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  tokenize(value, options) {\n    return Array.from(value);\n  }\n  join(chars) {\n    // Assumes ValueT is string, which is the case for most subclasses.\n    // When it's false, e.g. in diffArrays, this method needs to be overridden (e.g. with a no-op)\n    // Yes, the casts are verbose and ugly, because this pattern - of having the base class SORT OF\n    // assume tokens and values are strings, but not completely - is weird and janky.\n    return chars.join('');\n  }\n  postProcess(changeObjects,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  options) {\n    return changeObjects;\n  }\n  get useLongestToken() {\n    return false;\n  }\n  buildValues(lastComponent, newTokens, oldTokens) {\n    // First we convert our linked list of components in reverse order to an\n    // array in the right order:\n    const components = [];\n    let nextComponent;\n    while (lastComponent) {\n      components.push(lastComponent);\n      nextComponent = lastComponent.previousComponent;\n      delete lastComponent.previousComponent;\n      lastComponent = nextComponent;\n    }\n    components.reverse();\n    const componentLen = components.length;\n    let componentPos = 0,\n      newPos = 0,\n      oldPos = 0;\n    for (; componentPos < componentLen; componentPos++) {\n      const component = components[componentPos];\n      if (!component.removed) {\n        if (!component.added && this.useLongestToken) {\n          let value = newTokens.slice(newPos, newPos + component.count);\n          value = value.map(function (value, i) {\n            const oldValue = oldTokens[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n          component.value = this.join(value);\n        } else {\n          component.value = this.join(newTokens.slice(newPos, newPos + component.count));\n        }\n        newPos += component.count;\n        // Common case\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));\n        oldPos += component.count;\n      }\n    }\n    return components;\n  }\n}","map":{"version":3,"names":["Diff","diff","oldStr","newStr","options","arguments","length","undefined","callback","oldString","castInput","newString","oldTokens","removeEmpty","tokenize","newTokens","diffWithOptionsObj","_a","done","value","postProcess","setTimeout","newLen","oldLen","editLength","maxEditLength","Math","min","maxExecutionTime","timeout","Infinity","abortAfterTimestamp","Date","now","bestPath","oldPos","lastComponent","newPos","extractCommon","buildValues","minDiagonalToConsider","maxDiagonalToConsider","execEditLength","diagonalPath","max","basePath","removePath","addPath","canAdd","addPathNewPos","canRemove","addToPath","exec","ret","path","added","removed","oldPosInc","last","oneChangePerToken","count","previousComponent","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","i","push","Array","from","join","chars","changeObjects","useLongestToken","components","nextComponent","reverse","componentLen","componentPos","component","slice","map","oldValue"],"sources":["/Users/elias/Documents/Trabajo/Pruebas-del-IMSS/Simulacion/frontend/node_modules/diff/libesm/diff/base.js"],"sourcesContent":["export default class Diff {\n    diff(oldStr, newStr, \n    // Type below is not accurate/complete - see above for full possibilities - but it compiles\n    options = {}) {\n        let callback;\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        else if ('callback' in options) {\n            callback = options.callback;\n        }\n        // Allow subclasses to massage the input prior to running\n        const oldString = this.castInput(oldStr, options);\n        const newString = this.castInput(newStr, options);\n        const oldTokens = this.removeEmpty(this.tokenize(oldString, options));\n        const newTokens = this.removeEmpty(this.tokenize(newString, options));\n        return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);\n    }\n    diffWithOptionsObj(oldTokens, newTokens, options, callback) {\n        var _a;\n        const done = (value) => {\n            value = this.postProcess(value, options);\n            if (callback) {\n                setTimeout(function () { callback(value); }, 0);\n                return undefined;\n            }\n            else {\n                return value;\n            }\n        };\n        const newLen = newTokens.length, oldLen = oldTokens.length;\n        let editLength = 1;\n        let maxEditLength = newLen + oldLen;\n        if (options.maxEditLength != null) {\n            maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n        }\n        const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;\n        const abortAfterTimestamp = Date.now() + maxExecutionTime;\n        const bestPath = [{ oldPos: -1, lastComponent: undefined }];\n        // Seed editLength = 0, i.e. the content starts with the same values\n        let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);\n        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n            // Identity per the equality and tokenizer\n            return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));\n        }\n        // Once we hit the right edge of the edit graph on some diagonal k, we can\n        // definitely reach the end of the edit graph in no more than k edits, so\n        // there's no point in considering any moves to diagonal k+1 any more (from\n        // which we're guaranteed to need at least k+1 more edits).\n        // Similarly, once we've reached the bottom of the edit graph, there's no\n        // point considering moves to lower diagonals.\n        // We record this fact by setting minDiagonalToConsider and\n        // maxDiagonalToConsider to some finite value once we've hit the edge of\n        // the edit graph.\n        // This optimization is not faithful to the original algorithm presented in\n        // Myers's paper, which instead pointlessly extends D-paths off the end of\n        // the edit graph - see page 7 of Myers's paper which notes this point\n        // explicitly and illustrates it with a diagram. This has major performance\n        // implications for some common scenarios. For instance, to compute a diff\n        // where the new text simply appends d characters on the end of the\n        // original text of length n, the true Myers algorithm will take O(n+d^2)\n        // time while this optimization needs only O(n+d) time.\n        let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;\n        // Main worker method. checks all permutations of a given edit length for acceptance.\n        const execEditLength = () => {\n            for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n                let basePath;\n                const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];\n                if (removePath) {\n                    // No one else is going to attempt to use this value, clear it\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath - 1] = undefined;\n                }\n                let canAdd = false;\n                if (addPath) {\n                    // what newPos will be after we do an insertion:\n                    const addPathNewPos = addPath.oldPos - diagonalPath;\n                    canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n                }\n                const canRemove = removePath && removePath.oldPos + 1 < oldLen;\n                if (!canAdd && !canRemove) {\n                    // If this path is a terminal then prune\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath] = undefined;\n                    continue;\n                }\n                // Select the diagonal that we want to branch from. We select the prior\n                // path whose position in the old string is the farthest from the origin\n                // and does not pass the bounds of the diff graph\n                if (!canRemove || (canAdd && removePath.oldPos < addPath.oldPos)) {\n                    basePath = this.addToPath(addPath, true, false, 0, options);\n                }\n                else {\n                    basePath = this.addToPath(removePath, false, true, 1, options);\n                }\n                newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);\n                if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n                    // If we have hit the end of both strings, then we are done\n                    return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;\n                }\n                else {\n                    bestPath[diagonalPath] = basePath;\n                    if (basePath.oldPos + 1 >= oldLen) {\n                        maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n                    }\n                    if (newPos + 1 >= newLen) {\n                        minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n                    }\n                }\n            }\n            editLength++;\n        };\n        // Performs the length of edit iteration. Is a bit fugly as this has to support the\n        // sync and async mode which is never fun. Loops over execEditLength until a value\n        // is produced, or until the edit length exceeds options.maxEditLength (if given),\n        // in which case it will return undefined.\n        if (callback) {\n            (function exec() {\n                setTimeout(function () {\n                    if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n                        return callback(undefined);\n                    }\n                    if (!execEditLength()) {\n                        exec();\n                    }\n                }, 0);\n            }());\n        }\n        else {\n            while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n                const ret = execEditLength();\n                if (ret) {\n                    return ret;\n                }\n            }\n        }\n    }\n    addToPath(path, added, removed, oldPosInc, options) {\n        const last = path.lastComponent;\n        if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: last.count + 1, added: added, removed: removed, previousComponent: last.previousComponent }\n            };\n        }\n        else {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: 1, added: added, removed: removed, previousComponent: last }\n            };\n        }\n    }\n    extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {\n        const newLen = newTokens.length, oldLen = oldTokens.length;\n        let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;\n        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {\n            newPos++;\n            oldPos++;\n            commonCount++;\n            if (options.oneChangePerToken) {\n                basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };\n            }\n        }\n        if (commonCount && !options.oneChangePerToken) {\n            basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };\n        }\n        basePath.oldPos = oldPos;\n        return newPos;\n    }\n    equals(left, right, options) {\n        if (options.comparator) {\n            return options.comparator(left, right);\n        }\n        else {\n            return left === right\n                || (!!options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n        }\n    }\n    removeEmpty(array) {\n        const ret = [];\n        for (let i = 0; i < array.length; i++) {\n            if (array[i]) {\n                ret.push(array[i]);\n            }\n        }\n        return ret;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    castInput(value, options) {\n        return value;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    tokenize(value, options) {\n        return Array.from(value);\n    }\n    join(chars) {\n        // Assumes ValueT is string, which is the case for most subclasses.\n        // When it's false, e.g. in diffArrays, this method needs to be overridden (e.g. with a no-op)\n        // Yes, the casts are verbose and ugly, because this pattern - of having the base class SORT OF\n        // assume tokens and values are strings, but not completely - is weird and janky.\n        return chars.join('');\n    }\n    postProcess(changeObjects, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        return changeObjects;\n    }\n    get useLongestToken() {\n        return false;\n    }\n    buildValues(lastComponent, newTokens, oldTokens) {\n        // First we convert our linked list of components in reverse order to an\n        // array in the right order:\n        const components = [];\n        let nextComponent;\n        while (lastComponent) {\n            components.push(lastComponent);\n            nextComponent = lastComponent.previousComponent;\n            delete lastComponent.previousComponent;\n            lastComponent = nextComponent;\n        }\n        components.reverse();\n        const componentLen = components.length;\n        let componentPos = 0, newPos = 0, oldPos = 0;\n        for (; componentPos < componentLen; componentPos++) {\n            const component = components[componentPos];\n            if (!component.removed) {\n                if (!component.added && this.useLongestToken) {\n                    let value = newTokens.slice(newPos, newPos + component.count);\n                    value = value.map(function (value, i) {\n                        const oldValue = oldTokens[oldPos + i];\n                        return oldValue.length > value.length ? oldValue : value;\n                    });\n                    component.value = this.join(value);\n                }\n                else {\n                    component.value = this.join(newTokens.slice(newPos, newPos + component.count));\n                }\n                newPos += component.count;\n                // Common case\n                if (!component.added) {\n                    oldPos += component.count;\n                }\n            }\n            else {\n                component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));\n                oldPos += component.count;\n            }\n        }\n        return components;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}