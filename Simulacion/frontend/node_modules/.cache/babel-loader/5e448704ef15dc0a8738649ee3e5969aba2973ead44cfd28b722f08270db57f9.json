{"ast":null,"code":"import Diff from './base.js';\nimport { generateOptions } from '../util/params.js';\nclass LineDiff extends Diff {\n  constructor() {\n    super(...arguments);\n    this.tokenize = tokenize;\n  }\n  equals(left, right, options) {\n    // If we're ignoring whitespace, we need to normalise lines by stripping\n    // whitespace before checking equality. (This has an annoying interaction\n    // with newlineIsToken that requires special handling: if newlines get their\n    // own token, then we DON'T want to trim the *newline* tokens down to empty\n    // strings, since this would cause us to treat whitespace-only line content\n    // as equal to a separator between lines, which would be weird and\n    // inconsistent with the documented behavior of the options.)\n    if (options.ignoreWhitespace) {\n      if (!options.newlineIsToken || !left.includes('\\n')) {\n        left = left.trim();\n      }\n      if (!options.newlineIsToken || !right.includes('\\n')) {\n        right = right.trim();\n      }\n    } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {\n      if (left.endsWith('\\n')) {\n        left = left.slice(0, -1);\n      }\n      if (right.endsWith('\\n')) {\n        right = right.slice(0, -1);\n      }\n    }\n    return super.equals(left, right, options);\n  }\n}\nexport const lineDiff = new LineDiff();\nexport function diffLines(oldStr, newStr, options) {\n  return lineDiff.diff(oldStr, newStr, options);\n}\nexport function diffTrimmedLines(oldStr, newStr, options) {\n  options = generateOptions(options, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n// Exported standalone so it can be used from jsonDiff too.\nexport function tokenize(value, options) {\n  if (options.stripTrailingCr) {\n    // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n    value = value.replace(/\\r\\n/g, '\\n');\n  }\n  const retLines = [],\n    linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n  // Ignore the final empty token that occurs if the string ends with a new line\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  }\n  // Merge the content and line separators into single tokens\n  for (let i = 0; i < linesAndNewlines.length; i++) {\n    const line = linesAndNewlines[i];\n    if (i % 2 && !options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      retLines.push(line);\n    }\n  }\n  return retLines;\n}","map":{"version":3,"names":["Diff","generateOptions","LineDiff","constructor","arguments","tokenize","equals","left","right","options","ignoreWhitespace","newlineIsToken","includes","trim","ignoreNewlineAtEof","endsWith","slice","lineDiff","diffLines","oldStr","newStr","diff","diffTrimmedLines","value","stripTrailingCr","replace","retLines","linesAndNewlines","split","length","pop","i","line","push"],"sources":["/home/elias/Documentos/Simulacion/frontend/node_modules/diff/libesm/diff/line.js"],"sourcesContent":["import Diff from './base.js';\nimport { generateOptions } from '../util/params.js';\nclass LineDiff extends Diff {\n    constructor() {\n        super(...arguments);\n        this.tokenize = tokenize;\n    }\n    equals(left, right, options) {\n        // If we're ignoring whitespace, we need to normalise lines by stripping\n        // whitespace before checking equality. (This has an annoying interaction\n        // with newlineIsToken that requires special handling: if newlines get their\n        // own token, then we DON'T want to trim the *newline* tokens down to empty\n        // strings, since this would cause us to treat whitespace-only line content\n        // as equal to a separator between lines, which would be weird and\n        // inconsistent with the documented behavior of the options.)\n        if (options.ignoreWhitespace) {\n            if (!options.newlineIsToken || !left.includes('\\n')) {\n                left = left.trim();\n            }\n            if (!options.newlineIsToken || !right.includes('\\n')) {\n                right = right.trim();\n            }\n        }\n        else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {\n            if (left.endsWith('\\n')) {\n                left = left.slice(0, -1);\n            }\n            if (right.endsWith('\\n')) {\n                right = right.slice(0, -1);\n            }\n        }\n        return super.equals(left, right, options);\n    }\n}\nexport const lineDiff = new LineDiff();\nexport function diffLines(oldStr, newStr, options) {\n    return lineDiff.diff(oldStr, newStr, options);\n}\nexport function diffTrimmedLines(oldStr, newStr, options) {\n    options = generateOptions(options, { ignoreWhitespace: true });\n    return lineDiff.diff(oldStr, newStr, options);\n}\n// Exported standalone so it can be used from jsonDiff too.\nexport function tokenize(value, options) {\n    if (options.stripTrailingCr) {\n        // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n        value = value.replace(/\\r\\n/g, '\\n');\n    }\n    const retLines = [], linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n    // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n        linesAndNewlines.pop();\n    }\n    // Merge the content and line separators into single tokens\n    for (let i = 0; i < linesAndNewlines.length; i++) {\n        const line = linesAndNewlines[i];\n        if (i % 2 && !options.newlineIsToken) {\n            retLines[retLines.length - 1] += line;\n        }\n        else {\n            retLines.push(line);\n        }\n    }\n    return retLines;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}