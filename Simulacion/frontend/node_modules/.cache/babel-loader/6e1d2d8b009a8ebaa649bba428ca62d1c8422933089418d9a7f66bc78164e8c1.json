{"ast":null,"code":"/**\n * Parses a patch into structured data, in the same structure returned by `structuredPatch`.\n *\n * @return a JSON object representation of the a patch, suitable for use with the `applyPatch` method.\n */\nexport function parsePatch(uniDiff) {\n  const diffstr = uniDiff.split(/\\n/),\n    list = [];\n  let i = 0;\n  function parseIndex() {\n    const index = {};\n    list.push(index);\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      const line = diffstr[i];\n      // File header found, end parsing diff metadata\n      if (/^(---|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      }\n      // Diff index\n      const header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n      i++;\n    }\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n    // Parse hunks\n    index.hunks = [];\n    while (i < diffstr.length) {\n      const line = diffstr[i];\n      if (/^(Index:\\s|diff\\s|---\\s|\\+\\+\\+\\s|===================================================================)/.test(line)) {\n        break;\n      } else if (/^@@/.test(line)) {\n        index.hunks.push(parseHunk());\n      } else if (line) {\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(line));\n      } else {\n        i++;\n      }\n    }\n  }\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    const fileHeader = /^(---|\\+\\+\\+)\\s+(.*)\\r?$/.exec(diffstr[i]);\n    if (fileHeader) {\n      const data = fileHeader[2].split('\\t', 2),\n        header = (data[1] || '').trim();\n      let fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      if (fileHeader[1] === '---') {\n        index.oldFileName = fileName;\n        index.oldHeader = header;\n      } else {\n        index.newFileName = fileName;\n        index.newHeader = header;\n      }\n      i++;\n    }\n  }\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    var _a;\n    const chunkHeaderIndex = i,\n      chunkHeaderLine = diffstr[i++],\n      chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    const hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: []\n    };\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n    let addCount = 0,\n      removeCount = 0;\n    for (; i < diffstr.length && (removeCount < hunk.oldLines || addCount < hunk.newLines || ((_a = diffstr[i]) === null || _a === void 0 ? void 0 : _a.startsWith('\\\\'))); i++) {\n      const operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        throw new Error(\"Hunk at line \".concat(chunkHeaderIndex + 1, \" contained invalid line \").concat(diffstr[i]));\n      }\n    }\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n    // Perform sanity checking\n    if (addCount !== hunk.newLines) {\n      throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n    }\n    if (removeCount !== hunk.oldLines) {\n      throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n    }\n    return hunk;\n  }\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n  return list;\n}","map":{"version":3,"names":["parsePatch","uniDiff","diffstr","split","list","i","parseIndex","index","push","length","line","test","header","exec","parseFileHeader","hunks","parseHunk","Error","JSON","stringify","fileHeader","data","trim","fileName","replace","substr","oldFileName","oldHeader","newFileName","newHeader","_a","chunkHeaderIndex","chunkHeaderLine","chunkHeader","hunk","oldStart","oldLines","newStart","newLines","lines","addCount","removeCount","startsWith","operation","concat"],"sources":["/home/elias/Documentos/Simulacion/frontend/node_modules/diff/libesm/patch/parse.js"],"sourcesContent":["/**\n * Parses a patch into structured data, in the same structure returned by `structuredPatch`.\n *\n * @return a JSON object representation of the a patch, suitable for use with the `applyPatch` method.\n */\nexport function parsePatch(uniDiff) {\n    const diffstr = uniDiff.split(/\\n/), list = [];\n    let i = 0;\n    function parseIndex() {\n        const index = {};\n        list.push(index);\n        // Parse diff metadata\n        while (i < diffstr.length) {\n            const line = diffstr[i];\n            // File header found, end parsing diff metadata\n            if ((/^(---|\\+\\+\\+|@@)\\s/).test(line)) {\n                break;\n            }\n            // Diff index\n            const header = (/^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/).exec(line);\n            if (header) {\n                index.index = header[1];\n            }\n            i++;\n        }\n        // Parse file headers if they are defined. Unified diff requires them, but\n        // there's no technical issues to have an isolated hunk without file header\n        parseFileHeader(index);\n        parseFileHeader(index);\n        // Parse hunks\n        index.hunks = [];\n        while (i < diffstr.length) {\n            const line = diffstr[i];\n            if ((/^(Index:\\s|diff\\s|---\\s|\\+\\+\\+\\s|===================================================================)/).test(line)) {\n                break;\n            }\n            else if ((/^@@/).test(line)) {\n                index.hunks.push(parseHunk());\n            }\n            else if (line) {\n                throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(line));\n            }\n            else {\n                i++;\n            }\n        }\n    }\n    // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n    function parseFileHeader(index) {\n        const fileHeader = (/^(---|\\+\\+\\+)\\s+(.*)\\r?$/).exec(diffstr[i]);\n        if (fileHeader) {\n            const data = fileHeader[2].split('\\t', 2), header = (data[1] || '').trim();\n            let fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n            if ((/^\".*\"$/).test(fileName)) {\n                fileName = fileName.substr(1, fileName.length - 2);\n            }\n            if (fileHeader[1] === '---') {\n                index.oldFileName = fileName;\n                index.oldHeader = header;\n            }\n            else {\n                index.newFileName = fileName;\n                index.newHeader = header;\n            }\n            i++;\n        }\n    }\n    // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n    function parseHunk() {\n        var _a;\n        const chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n        const hunk = {\n            oldStart: +chunkHeader[1],\n            oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n            newStart: +chunkHeader[3],\n            newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n            lines: []\n        };\n        // Unified Diff Format quirk: If the chunk size is 0,\n        // the first number is one lower than one would expect.\n        // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n        if (hunk.oldLines === 0) {\n            hunk.oldStart += 1;\n        }\n        if (hunk.newLines === 0) {\n            hunk.newStart += 1;\n        }\n        let addCount = 0, removeCount = 0;\n        for (; i < diffstr.length && (removeCount < hunk.oldLines || addCount < hunk.newLines || ((_a = diffstr[i]) === null || _a === void 0 ? void 0 : _a.startsWith('\\\\'))); i++) {\n            const operation = (diffstr[i].length == 0 && i != (diffstr.length - 1)) ? ' ' : diffstr[i][0];\n            if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n                hunk.lines.push(diffstr[i]);\n                if (operation === '+') {\n                    addCount++;\n                }\n                else if (operation === '-') {\n                    removeCount++;\n                }\n                else if (operation === ' ') {\n                    addCount++;\n                    removeCount++;\n                }\n            }\n            else {\n                throw new Error(`Hunk at line ${chunkHeaderIndex + 1} contained invalid line ${diffstr[i]}`);\n            }\n        }\n        // Handle the empty block count case\n        if (!addCount && hunk.newLines === 1) {\n            hunk.newLines = 0;\n        }\n        if (!removeCount && hunk.oldLines === 1) {\n            hunk.oldLines = 0;\n        }\n        // Perform sanity checking\n        if (addCount !== hunk.newLines) {\n            throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n        if (removeCount !== hunk.oldLines) {\n            throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n        return hunk;\n    }\n    while (i < diffstr.length) {\n        parseIndex();\n    }\n    return list;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}