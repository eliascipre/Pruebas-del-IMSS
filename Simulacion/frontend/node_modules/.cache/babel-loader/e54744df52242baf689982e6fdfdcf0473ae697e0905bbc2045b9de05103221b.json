{"ast":null,"code":"import Diff from './base.js';\nimport { tokenize } from './line.js';\nclass JsonDiff extends Diff {\n  constructor() {\n    super(...arguments);\n    this.tokenize = tokenize;\n  }\n  get useLongestToken() {\n    // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n    // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n    return true;\n  }\n  castInput(value, options) {\n    const {\n      undefinedReplacement,\n      stringifyReplacer = (k, v) => typeof v === 'undefined' ? undefinedReplacement : v\n    } = options;\n    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), null, '  ');\n  }\n  equals(left, right, options) {\n    return super.equals(left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'), options);\n  }\n}\nexport const jsonDiff = new JsonDiff();\nexport function diffJson(oldStr, newStr, options) {\n  return jsonDiff.diff(oldStr, newStr, options);\n}\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nexport function canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n  if (replacer) {\n    obj = replacer(key === undefined ? '' : key, obj);\n  }\n  let i;\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n  let canonicalizedObj;\n  if ('[object Array]' === Object.prototype.toString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, String(i));\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n  if (typeof obj === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    const sortedKeys = [];\n    let key;\n    for (key in obj) {\n      /* istanbul ignore else */\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        sortedKeys.push(key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      key = sortedKeys[i];\n      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}","map":{"version":3,"names":["Diff","tokenize","JsonDiff","constructor","arguments","useLongestToken","castInput","value","options","undefinedReplacement","stringifyReplacer","k","v","JSON","stringify","canonicalize","equals","left","right","replace","jsonDiff","diffJson","oldStr","newStr","diff","obj","stack","replacementStack","replacer","key","undefined","i","length","canonicalizedObj","Object","prototype","toString","call","push","Array","String","pop","toJSON","sortedKeys","hasOwnProperty","sort"],"sources":["/Users/elias/Documents/Trabajo/Pruebas-del-IMSS/Simulacion/frontend/node_modules/diff/libesm/diff/json.js"],"sourcesContent":["import Diff from './base.js';\nimport { tokenize } from './line.js';\nclass JsonDiff extends Diff {\n    constructor() {\n        super(...arguments);\n        this.tokenize = tokenize;\n    }\n    get useLongestToken() {\n        // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n        // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n        return true;\n    }\n    castInput(value, options) {\n        const { undefinedReplacement, stringifyReplacer = (k, v) => typeof v === 'undefined' ? undefinedReplacement : v } = options;\n        return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), null, '  ');\n    }\n    equals(left, right, options) {\n        return super.equals(left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'), options);\n    }\n}\nexport const jsonDiff = new JsonDiff();\nexport function diffJson(oldStr, newStr, options) {\n    return jsonDiff.diff(oldStr, newStr, options);\n}\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nexport function canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n    if (replacer) {\n        obj = replacer(key === undefined ? '' : key, obj);\n    }\n    let i;\n    for (i = 0; i < stack.length; i += 1) {\n        if (stack[i] === obj) {\n            return replacementStack[i];\n        }\n    }\n    let canonicalizedObj;\n    if ('[object Array]' === Object.prototype.toString.call(obj)) {\n        stack.push(obj);\n        canonicalizedObj = new Array(obj.length);\n        replacementStack.push(canonicalizedObj);\n        for (i = 0; i < obj.length; i += 1) {\n            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, String(i));\n        }\n        stack.pop();\n        replacementStack.pop();\n        return canonicalizedObj;\n    }\n    if (obj && obj.toJSON) {\n        obj = obj.toJSON();\n    }\n    if (typeof obj === 'object' && obj !== null) {\n        stack.push(obj);\n        canonicalizedObj = {};\n        replacementStack.push(canonicalizedObj);\n        const sortedKeys = [];\n        let key;\n        for (key in obj) {\n            /* istanbul ignore else */\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                sortedKeys.push(key);\n            }\n        }\n        sortedKeys.sort();\n        for (i = 0; i < sortedKeys.length; i += 1) {\n            key = sortedKeys[i];\n            canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack, replacer, key);\n        }\n        stack.pop();\n        replacementStack.pop();\n    }\n    else {\n        canonicalizedObj = obj;\n    }\n    return canonicalizedObj;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}