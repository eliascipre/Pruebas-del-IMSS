{"ast":null,"code":"import { hasOnlyWinLineEndings, hasOnlyUnixLineEndings } from '../util/string.js';\nimport { isWin, isUnix, unixToWin, winToUnix } from './line-endings.js';\nimport { parsePatch } from './parse.js';\nimport distanceIterator from '../util/distance-iterator.js';\n/**\n * attempts to apply a unified diff patch.\n *\n * Hunks are applied first to last.\n * `applyPatch` first tries to apply the first hunk at the line number specified in the hunk header, and with all context lines matching exactly.\n * If that fails, it tries scanning backwards and forwards, one line at a time, to find a place to apply the hunk where the context lines match exactly.\n * If that still fails, and `fuzzFactor` is greater than zero, it increments the maximum number of mismatches (missing, extra, or changed context lines) that there can be between the hunk context and a region where we are trying to apply the patch such that the hunk will still be considered to match.\n * Regardless of `fuzzFactor`, lines to be deleted in the hunk *must* be present for a hunk to match, and the context lines *immediately* before and after an insertion must match exactly.\n *\n * Once a hunk is successfully fitted, the process begins again with the next hunk.\n * Regardless of `fuzzFactor`, later hunks must be applied later in the file than earlier hunks.\n *\n * If a hunk cannot be successfully fitted *anywhere* with fewer than `fuzzFactor` mismatches, `applyPatch` fails and returns `false`.\n *\n * If a hunk is successfully fitted but not at the line number specified by the hunk header, all subsequent hunks have their target line number adjusted accordingly.\n * (e.g. if the first hunk is applied 10 lines below where the hunk header said it should fit, `applyPatch` will *start* looking for somewhere to apply the second hunk 10 lines below where its hunk header says it goes.)\n *\n * If the patch was applied successfully, returns a string containing the patched text.\n * If the patch could not be applied (because some hunks in the patch couldn't be fitted to the text in `source`), `applyPatch` returns false.\n *\n * @param patch a string diff or the output from the `parsePatch` or `structuredPatch` methods.\n */\nexport function applyPatch(source, patch) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let patches;\n  if (typeof patch === 'string') {\n    patches = parsePatch(patch);\n  } else if (Array.isArray(patch)) {\n    patches = patch;\n  } else {\n    patches = [patch];\n  }\n  if (patches.length > 1) {\n    throw new Error('applyPatch only works with a single input.');\n  }\n  return applyStructuredPatch(source, patches[0], options);\n}\nfunction applyStructuredPatch(source, patch) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (options.autoConvertLineEndings || options.autoConvertLineEndings == null) {\n    if (hasOnlyWinLineEndings(source) && isUnix(patch)) {\n      patch = unixToWin(patch);\n    } else if (hasOnlyUnixLineEndings(source) && isWin(patch)) {\n      patch = winToUnix(patch);\n    }\n  }\n  // Apply the diff to the input\n  const lines = source.split('\\n'),\n    hunks = patch.hunks,\n    compareLine = options.compareLine || ((lineNumber, line, operation, patchContent) => line === patchContent),\n    fuzzFactor = options.fuzzFactor || 0;\n  let minLine = 0;\n  if (fuzzFactor < 0 || !Number.isInteger(fuzzFactor)) {\n    throw new Error('fuzzFactor must be a non-negative integer');\n  }\n  // Special case for empty patch.\n  if (!hunks.length) {\n    return source;\n  }\n  // Before anything else, handle EOFNL insertion/removal. If the patch tells us to make a change\n  // to the EOFNL that is redundant/impossible - i.e. to remove a newline that's not there, or add a\n  // newline that already exists - then we either return false and fail to apply the patch (if\n  // fuzzFactor is 0) or simply ignore the problem and do nothing (if fuzzFactor is >0).\n  // If we do need to remove/add a newline at EOF, this will always be in the final hunk:\n  let prevLine = '',\n    removeEOFNL = false,\n    addEOFNL = false;\n  for (let i = 0; i < hunks[hunks.length - 1].lines.length; i++) {\n    const line = hunks[hunks.length - 1].lines[i];\n    if (line[0] == '\\\\') {\n      if (prevLine[0] == '+') {\n        removeEOFNL = true;\n      } else if (prevLine[0] == '-') {\n        addEOFNL = true;\n      }\n    }\n    prevLine = line;\n  }\n  if (removeEOFNL) {\n    if (addEOFNL) {\n      // This means the final line gets changed but doesn't have a trailing newline in either the\n      // original or patched version. In that case, we do nothing if fuzzFactor > 0, and if\n      // fuzzFactor is 0, we simply validate that the source file has no trailing newline.\n      if (!fuzzFactor && lines[lines.length - 1] == '') {\n        return false;\n      }\n    } else if (lines[lines.length - 1] == '') {\n      lines.pop();\n    } else if (!fuzzFactor) {\n      return false;\n    }\n  } else if (addEOFNL) {\n    if (lines[lines.length - 1] != '') {\n      lines.push('');\n    } else if (!fuzzFactor) {\n      return false;\n    }\n  }\n  /**\n   * Checks if the hunk can be made to fit at the provided location with at most `maxErrors`\n   * insertions, substitutions, or deletions, while ensuring also that:\n   * - lines deleted in the hunk match exactly, and\n   * - wherever an insertion operation or block of insertion operations appears in the hunk, the\n   *   immediately preceding and following lines of context match exactly\n   *\n   * `toPos` should be set such that lines[toPos] is meant to match hunkLines[0].\n   *\n   * If the hunk can be applied, returns an object with properties `oldLineLastI` and\n   * `replacementLines`. Otherwise, returns null.\n   */\n  function applyHunk(hunkLines, toPos, maxErrors) {\n    let hunkLinesI = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let lastContextLineMatched = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let patchedLines = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n    let patchedLinesLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    let nConsecutiveOldContextLines = 0;\n    let nextContextLineMustMatch = false;\n    for (; hunkLinesI < hunkLines.length; hunkLinesI++) {\n      const hunkLine = hunkLines[hunkLinesI],\n        operation = hunkLine.length > 0 ? hunkLine[0] : ' ',\n        content = hunkLine.length > 0 ? hunkLine.substr(1) : hunkLine;\n      if (operation === '-') {\n        if (compareLine(toPos + 1, lines[toPos], operation, content)) {\n          toPos++;\n          nConsecutiveOldContextLines = 0;\n        } else {\n          if (!maxErrors || lines[toPos] == null) {\n            return null;\n          }\n          patchedLines[patchedLinesLength] = lines[toPos];\n          return applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1);\n        }\n      }\n      if (operation === '+') {\n        if (!lastContextLineMatched) {\n          return null;\n        }\n        patchedLines[patchedLinesLength] = content;\n        patchedLinesLength++;\n        nConsecutiveOldContextLines = 0;\n        nextContextLineMustMatch = true;\n      }\n      if (operation === ' ') {\n        nConsecutiveOldContextLines++;\n        patchedLines[patchedLinesLength] = lines[toPos];\n        if (compareLine(toPos + 1, lines[toPos], operation, content)) {\n          patchedLinesLength++;\n          lastContextLineMatched = true;\n          nextContextLineMustMatch = false;\n          toPos++;\n        } else {\n          if (nextContextLineMustMatch || !maxErrors) {\n            return null;\n          }\n          // Consider 3 possibilities in sequence:\n          // 1. lines contains a *substitution* not included in the patch context, or\n          // 2. lines contains an *insertion* not included in the patch context, or\n          // 3. lines contains a *deletion* not included in the patch context\n          // The first two options are of course only possible if the line from lines is non-null -\n          // i.e. only option 3 is possible if we've overrun the end of the old file.\n          return lines[toPos] && (applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength + 1) || applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1)) || applyHunk(hunkLines, toPos, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength);\n        }\n      }\n    }\n    // Before returning, trim any unmodified context lines off the end of patchedLines and reduce\n    // toPos (and thus oldLineLastI) accordingly. This allows later hunks to be applied to a region\n    // that starts in this hunk's trailing context.\n    patchedLinesLength -= nConsecutiveOldContextLines;\n    toPos -= nConsecutiveOldContextLines;\n    patchedLines.length = patchedLinesLength;\n    return {\n      patchedLines,\n      oldLineLastI: toPos - 1\n    };\n  }\n  const resultLines = [];\n  // Search best fit offsets for each hunk based on the previous ones\n  let prevHunkOffset = 0;\n  for (let i = 0; i < hunks.length; i++) {\n    const hunk = hunks[i];\n    let hunkResult;\n    const maxLine = lines.length - hunk.oldLines + fuzzFactor;\n    let toPos;\n    for (let maxErrors = 0; maxErrors <= fuzzFactor; maxErrors++) {\n      toPos = hunk.oldStart + prevHunkOffset - 1;\n      const iterator = distanceIterator(toPos, minLine, maxLine);\n      for (; toPos !== undefined; toPos = iterator()) {\n        hunkResult = applyHunk(hunk.lines, toPos, maxErrors);\n        if (hunkResult) {\n          break;\n        }\n      }\n      if (hunkResult) {\n        break;\n      }\n    }\n    if (!hunkResult) {\n      return false;\n    }\n    // Copy everything from the end of where we applied the last hunk to the start of this hunk\n    for (let i = minLine; i < toPos; i++) {\n      resultLines.push(lines[i]);\n    }\n    // Add the lines produced by applying the hunk:\n    for (let i = 0; i < hunkResult.patchedLines.length; i++) {\n      const line = hunkResult.patchedLines[i];\n      resultLines.push(line);\n    }\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunkResult.oldLineLastI + 1;\n    // Note the offset between where the patch said the hunk should've applied and where we\n    // applied it, so we can adjust future hunks accordingly:\n    prevHunkOffset = toPos + 1 - hunk.oldStart;\n  }\n  // Copy over the rest of the lines from the old text\n  for (let i = minLine; i < lines.length; i++) {\n    resultLines.push(lines[i]);\n  }\n  return resultLines.join('\\n');\n}\n/**\n * applies one or more patches.\n *\n * `patch` may be either an array of structured patch objects, or a string representing a patch in unified diff format (which may patch one or more files).\n *\n * This method will iterate over the contents of the patch and apply to data provided through callbacks. The general flow for each patch index is:\n *\n * - `options.loadFile(index, callback)` is called. The caller should then load the contents of the file and then pass that to the `callback(err, data)` callback. Passing an `err` will terminate further patch execution.\n * - `options.patched(index, content, callback)` is called once the patch has been applied. `content` will be the return value from `applyPatch`. When it's ready, the caller should call `callback(err)` callback. Passing an `err` will terminate further patch execution.\n *\n * Once all patches have been applied or an error occurs, the `options.complete(err)` callback is made.\n */\nexport function applyPatches(uniDiff, options) {\n  const spDiff = typeof uniDiff === 'string' ? parsePatch(uniDiff) : uniDiff;\n  let currentIndex = 0;\n  function processIndex() {\n    const index = spDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n      const updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}","map":{"version":3,"names":["hasOnlyWinLineEndings","hasOnlyUnixLineEndings","isWin","isUnix","unixToWin","winToUnix","parsePatch","distanceIterator","applyPatch","source","patch","options","arguments","length","undefined","patches","Array","isArray","Error","applyStructuredPatch","autoConvertLineEndings","lines","split","hunks","compareLine","lineNumber","line","operation","patchContent","fuzzFactor","minLine","Number","isInteger","prevLine","removeEOFNL","addEOFNL","i","pop","push","applyHunk","hunkLines","toPos","maxErrors","hunkLinesI","lastContextLineMatched","patchedLines","patchedLinesLength","nConsecutiveOldContextLines","nextContextLineMustMatch","hunkLine","content","substr","oldLineLastI","resultLines","prevHunkOffset","hunk","hunkResult","maxLine","oldLines","oldStart","iterator","join","applyPatches","uniDiff","spDiff","currentIndex","processIndex","index","complete","loadFile","err","data","updatedContent","patched"],"sources":["/home/elias/Documentos/Simulacion/frontend/node_modules/diff/libesm/patch/apply.js"],"sourcesContent":["import { hasOnlyWinLineEndings, hasOnlyUnixLineEndings } from '../util/string.js';\nimport { isWin, isUnix, unixToWin, winToUnix } from './line-endings.js';\nimport { parsePatch } from './parse.js';\nimport distanceIterator from '../util/distance-iterator.js';\n/**\n * attempts to apply a unified diff patch.\n *\n * Hunks are applied first to last.\n * `applyPatch` first tries to apply the first hunk at the line number specified in the hunk header, and with all context lines matching exactly.\n * If that fails, it tries scanning backwards and forwards, one line at a time, to find a place to apply the hunk where the context lines match exactly.\n * If that still fails, and `fuzzFactor` is greater than zero, it increments the maximum number of mismatches (missing, extra, or changed context lines) that there can be between the hunk context and a region where we are trying to apply the patch such that the hunk will still be considered to match.\n * Regardless of `fuzzFactor`, lines to be deleted in the hunk *must* be present for a hunk to match, and the context lines *immediately* before and after an insertion must match exactly.\n *\n * Once a hunk is successfully fitted, the process begins again with the next hunk.\n * Regardless of `fuzzFactor`, later hunks must be applied later in the file than earlier hunks.\n *\n * If a hunk cannot be successfully fitted *anywhere* with fewer than `fuzzFactor` mismatches, `applyPatch` fails and returns `false`.\n *\n * If a hunk is successfully fitted but not at the line number specified by the hunk header, all subsequent hunks have their target line number adjusted accordingly.\n * (e.g. if the first hunk is applied 10 lines below where the hunk header said it should fit, `applyPatch` will *start* looking for somewhere to apply the second hunk 10 lines below where its hunk header says it goes.)\n *\n * If the patch was applied successfully, returns a string containing the patched text.\n * If the patch could not be applied (because some hunks in the patch couldn't be fitted to the text in `source`), `applyPatch` returns false.\n *\n * @param patch a string diff or the output from the `parsePatch` or `structuredPatch` methods.\n */\nexport function applyPatch(source, patch, options = {}) {\n    let patches;\n    if (typeof patch === 'string') {\n        patches = parsePatch(patch);\n    }\n    else if (Array.isArray(patch)) {\n        patches = patch;\n    }\n    else {\n        patches = [patch];\n    }\n    if (patches.length > 1) {\n        throw new Error('applyPatch only works with a single input.');\n    }\n    return applyStructuredPatch(source, patches[0], options);\n}\nfunction applyStructuredPatch(source, patch, options = {}) {\n    if (options.autoConvertLineEndings || options.autoConvertLineEndings == null) {\n        if (hasOnlyWinLineEndings(source) && isUnix(patch)) {\n            patch = unixToWin(patch);\n        }\n        else if (hasOnlyUnixLineEndings(source) && isWin(patch)) {\n            patch = winToUnix(patch);\n        }\n    }\n    // Apply the diff to the input\n    const lines = source.split('\\n'), hunks = patch.hunks, compareLine = options.compareLine || ((lineNumber, line, operation, patchContent) => line === patchContent), fuzzFactor = options.fuzzFactor || 0;\n    let minLine = 0;\n    if (fuzzFactor < 0 || !Number.isInteger(fuzzFactor)) {\n        throw new Error('fuzzFactor must be a non-negative integer');\n    }\n    // Special case for empty patch.\n    if (!hunks.length) {\n        return source;\n    }\n    // Before anything else, handle EOFNL insertion/removal. If the patch tells us to make a change\n    // to the EOFNL that is redundant/impossible - i.e. to remove a newline that's not there, or add a\n    // newline that already exists - then we either return false and fail to apply the patch (if\n    // fuzzFactor is 0) or simply ignore the problem and do nothing (if fuzzFactor is >0).\n    // If we do need to remove/add a newline at EOF, this will always be in the final hunk:\n    let prevLine = '', removeEOFNL = false, addEOFNL = false;\n    for (let i = 0; i < hunks[hunks.length - 1].lines.length; i++) {\n        const line = hunks[hunks.length - 1].lines[i];\n        if (line[0] == '\\\\') {\n            if (prevLine[0] == '+') {\n                removeEOFNL = true;\n            }\n            else if (prevLine[0] == '-') {\n                addEOFNL = true;\n            }\n        }\n        prevLine = line;\n    }\n    if (removeEOFNL) {\n        if (addEOFNL) {\n            // This means the final line gets changed but doesn't have a trailing newline in either the\n            // original or patched version. In that case, we do nothing if fuzzFactor > 0, and if\n            // fuzzFactor is 0, we simply validate that the source file has no trailing newline.\n            if (!fuzzFactor && lines[lines.length - 1] == '') {\n                return false;\n            }\n        }\n        else if (lines[lines.length - 1] == '') {\n            lines.pop();\n        }\n        else if (!fuzzFactor) {\n            return false;\n        }\n    }\n    else if (addEOFNL) {\n        if (lines[lines.length - 1] != '') {\n            lines.push('');\n        }\n        else if (!fuzzFactor) {\n            return false;\n        }\n    }\n    /**\n     * Checks if the hunk can be made to fit at the provided location with at most `maxErrors`\n     * insertions, substitutions, or deletions, while ensuring also that:\n     * - lines deleted in the hunk match exactly, and\n     * - wherever an insertion operation or block of insertion operations appears in the hunk, the\n     *   immediately preceding and following lines of context match exactly\n     *\n     * `toPos` should be set such that lines[toPos] is meant to match hunkLines[0].\n     *\n     * If the hunk can be applied, returns an object with properties `oldLineLastI` and\n     * `replacementLines`. Otherwise, returns null.\n     */\n    function applyHunk(hunkLines, toPos, maxErrors, hunkLinesI = 0, lastContextLineMatched = true, patchedLines = [], patchedLinesLength = 0) {\n        let nConsecutiveOldContextLines = 0;\n        let nextContextLineMustMatch = false;\n        for (; hunkLinesI < hunkLines.length; hunkLinesI++) {\n            const hunkLine = hunkLines[hunkLinesI], operation = (hunkLine.length > 0 ? hunkLine[0] : ' '), content = (hunkLine.length > 0 ? hunkLine.substr(1) : hunkLine);\n            if (operation === '-') {\n                if (compareLine(toPos + 1, lines[toPos], operation, content)) {\n                    toPos++;\n                    nConsecutiveOldContextLines = 0;\n                }\n                else {\n                    if (!maxErrors || lines[toPos] == null) {\n                        return null;\n                    }\n                    patchedLines[patchedLinesLength] = lines[toPos];\n                    return applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1);\n                }\n            }\n            if (operation === '+') {\n                if (!lastContextLineMatched) {\n                    return null;\n                }\n                patchedLines[patchedLinesLength] = content;\n                patchedLinesLength++;\n                nConsecutiveOldContextLines = 0;\n                nextContextLineMustMatch = true;\n            }\n            if (operation === ' ') {\n                nConsecutiveOldContextLines++;\n                patchedLines[patchedLinesLength] = lines[toPos];\n                if (compareLine(toPos + 1, lines[toPos], operation, content)) {\n                    patchedLinesLength++;\n                    lastContextLineMatched = true;\n                    nextContextLineMustMatch = false;\n                    toPos++;\n                }\n                else {\n                    if (nextContextLineMustMatch || !maxErrors) {\n                        return null;\n                    }\n                    // Consider 3 possibilities in sequence:\n                    // 1. lines contains a *substitution* not included in the patch context, or\n                    // 2. lines contains an *insertion* not included in the patch context, or\n                    // 3. lines contains a *deletion* not included in the patch context\n                    // The first two options are of course only possible if the line from lines is non-null -\n                    // i.e. only option 3 is possible if we've overrun the end of the old file.\n                    return (lines[toPos] && (applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength + 1) || applyHunk(hunkLines, toPos + 1, maxErrors - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1)) || applyHunk(hunkLines, toPos, maxErrors - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength));\n                }\n            }\n        }\n        // Before returning, trim any unmodified context lines off the end of patchedLines and reduce\n        // toPos (and thus oldLineLastI) accordingly. This allows later hunks to be applied to a region\n        // that starts in this hunk's trailing context.\n        patchedLinesLength -= nConsecutiveOldContextLines;\n        toPos -= nConsecutiveOldContextLines;\n        patchedLines.length = patchedLinesLength;\n        return {\n            patchedLines,\n            oldLineLastI: toPos - 1\n        };\n    }\n    const resultLines = [];\n    // Search best fit offsets for each hunk based on the previous ones\n    let prevHunkOffset = 0;\n    for (let i = 0; i < hunks.length; i++) {\n        const hunk = hunks[i];\n        let hunkResult;\n        const maxLine = lines.length - hunk.oldLines + fuzzFactor;\n        let toPos;\n        for (let maxErrors = 0; maxErrors <= fuzzFactor; maxErrors++) {\n            toPos = hunk.oldStart + prevHunkOffset - 1;\n            const iterator = distanceIterator(toPos, minLine, maxLine);\n            for (; toPos !== undefined; toPos = iterator()) {\n                hunkResult = applyHunk(hunk.lines, toPos, maxErrors);\n                if (hunkResult) {\n                    break;\n                }\n            }\n            if (hunkResult) {\n                break;\n            }\n        }\n        if (!hunkResult) {\n            return false;\n        }\n        // Copy everything from the end of where we applied the last hunk to the start of this hunk\n        for (let i = minLine; i < toPos; i++) {\n            resultLines.push(lines[i]);\n        }\n        // Add the lines produced by applying the hunk:\n        for (let i = 0; i < hunkResult.patchedLines.length; i++) {\n            const line = hunkResult.patchedLines[i];\n            resultLines.push(line);\n        }\n        // Set lower text limit to end of the current hunk, so next ones don't try\n        // to fit over already patched text\n        minLine = hunkResult.oldLineLastI + 1;\n        // Note the offset between where the patch said the hunk should've applied and where we\n        // applied it, so we can adjust future hunks accordingly:\n        prevHunkOffset = toPos + 1 - hunk.oldStart;\n    }\n    // Copy over the rest of the lines from the old text\n    for (let i = minLine; i < lines.length; i++) {\n        resultLines.push(lines[i]);\n    }\n    return resultLines.join('\\n');\n}\n/**\n * applies one or more patches.\n *\n * `patch` may be either an array of structured patch objects, or a string representing a patch in unified diff format (which may patch one or more files).\n *\n * This method will iterate over the contents of the patch and apply to data provided through callbacks. The general flow for each patch index is:\n *\n * - `options.loadFile(index, callback)` is called. The caller should then load the contents of the file and then pass that to the `callback(err, data)` callback. Passing an `err` will terminate further patch execution.\n * - `options.patched(index, content, callback)` is called once the patch has been applied. `content` will be the return value from `applyPatch`. When it's ready, the caller should call `callback(err)` callback. Passing an `err` will terminate further patch execution.\n *\n * Once all patches have been applied or an error occurs, the `options.complete(err)` callback is made.\n */\nexport function applyPatches(uniDiff, options) {\n    const spDiff = typeof uniDiff === 'string' ? parsePatch(uniDiff) : uniDiff;\n    let currentIndex = 0;\n    function processIndex() {\n        const index = spDiff[currentIndex++];\n        if (!index) {\n            return options.complete();\n        }\n        options.loadFile(index, function (err, data) {\n            if (err) {\n                return options.complete(err);\n            }\n            const updatedContent = applyPatch(data, index, options);\n            options.patched(index, updatedContent, function (err) {\n                if (err) {\n                    return options.complete(err);\n                }\n                processIndex();\n            });\n        });\n    }\n    processIndex();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}