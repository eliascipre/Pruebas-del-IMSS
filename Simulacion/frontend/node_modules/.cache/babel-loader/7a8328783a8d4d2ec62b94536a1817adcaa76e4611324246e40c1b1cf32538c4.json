{"ast":null,"code":"import Diff from './base.js';\nfunction isSentenceEndPunct(char) {\n  return char == '.' || char == '!' || char == '?';\n}\nclass SentenceDiff extends Diff {\n  tokenize(value) {\n    var _a;\n    // If in future we drop support for environments that don't support lookbehinds, we can replace\n    // this entire function with:\n    //     return value.split(/(?<=[.!?])(\\s+|$)/);\n    // but until then, for similar reasons to the trailingWs function in string.ts, we are forced\n    // to do this verbosely \"by hand\" instead of using a regex.\n    const result = [];\n    let tokenStartI = 0;\n    for (let i = 0; i < value.length; i++) {\n      if (i == value.length - 1) {\n        result.push(value.slice(tokenStartI));\n        break;\n      }\n      if (isSentenceEndPunct(value[i]) && value[i + 1].match(/\\s/)) {\n        // We've hit a sentence break - i.e. a punctuation mark followed by whitespace.\n        // We now want to push TWO tokens to the result:\n        // 1. the sentence\n        result.push(value.slice(tokenStartI, i + 1));\n        // 2. the whitespace\n        i = tokenStartI = i + 1;\n        while ((_a = value[i + 1]) === null || _a === void 0 ? void 0 : _a.match(/\\s/)) {\n          i++;\n        }\n        result.push(value.slice(tokenStartI, i + 1));\n        // Then the next token (a sentence) starts on the character after the whitespace.\n        // (It's okay if this is off the end of the string - then the outer loop will terminate\n        // here anyway.)\n        tokenStartI = i + 1;\n      }\n    }\n    return result;\n  }\n}\nexport const sentenceDiff = new SentenceDiff();\nexport function diffSentences(oldStr, newStr, options) {\n  return sentenceDiff.diff(oldStr, newStr, options);\n}","map":{"version":3,"names":["Diff","isSentenceEndPunct","char","SentenceDiff","tokenize","value","_a","result","tokenStartI","i","length","push","slice","match","sentenceDiff","diffSentences","oldStr","newStr","options","diff"],"sources":["/Users/elias/Documents/Trabajo/Pruebas-del-IMSS/Simulacion/frontend/node_modules/diff/libesm/diff/sentence.js"],"sourcesContent":["import Diff from './base.js';\nfunction isSentenceEndPunct(char) {\n    return char == '.' || char == '!' || char == '?';\n}\nclass SentenceDiff extends Diff {\n    tokenize(value) {\n        var _a;\n        // If in future we drop support for environments that don't support lookbehinds, we can replace\n        // this entire function with:\n        //     return value.split(/(?<=[.!?])(\\s+|$)/);\n        // but until then, for similar reasons to the trailingWs function in string.ts, we are forced\n        // to do this verbosely \"by hand\" instead of using a regex.\n        const result = [];\n        let tokenStartI = 0;\n        for (let i = 0; i < value.length; i++) {\n            if (i == value.length - 1) {\n                result.push(value.slice(tokenStartI));\n                break;\n            }\n            if (isSentenceEndPunct(value[i]) && value[i + 1].match(/\\s/)) {\n                // We've hit a sentence break - i.e. a punctuation mark followed by whitespace.\n                // We now want to push TWO tokens to the result:\n                // 1. the sentence\n                result.push(value.slice(tokenStartI, i + 1));\n                // 2. the whitespace\n                i = tokenStartI = i + 1;\n                while ((_a = value[i + 1]) === null || _a === void 0 ? void 0 : _a.match(/\\s/)) {\n                    i++;\n                }\n                result.push(value.slice(tokenStartI, i + 1));\n                // Then the next token (a sentence) starts on the character after the whitespace.\n                // (It's okay if this is off the end of the string - then the outer loop will terminate\n                // here anyway.)\n                tokenStartI = i + 1;\n            }\n        }\n        return result;\n    }\n}\nexport const sentenceDiff = new SentenceDiff();\nexport function diffSentences(oldStr, newStr, options) {\n    return sentenceDiff.diff(oldStr, newStr, options);\n}\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,WAAW;AAC5B,SAASC,kBAAkBA,CAACC,IAAI,EAAE;EAC9B,OAAOA,IAAI,IAAI,GAAG,IAAIA,IAAI,IAAI,GAAG,IAAIA,IAAI,IAAI,GAAG;AACpD;AACA,MAAMC,YAAY,SAASH,IAAI,CAAC;EAC5BI,QAAQA,CAACC,KAAK,EAAE;IACZ,IAAIC,EAAE;IACN;IACA;IACA;IACA;IACA;IACA,MAAMC,MAAM,GAAG,EAAE;IACjB,IAAIC,WAAW,GAAG,CAAC;IACnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;MACnC,IAAIA,CAAC,IAAIJ,KAAK,CAACK,MAAM,GAAG,CAAC,EAAE;QACvBH,MAAM,CAACI,IAAI,CAACN,KAAK,CAACO,KAAK,CAACJ,WAAW,CAAC,CAAC;QACrC;MACJ;MACA,IAAIP,kBAAkB,CAACI,KAAK,CAACI,CAAC,CAAC,CAAC,IAAIJ,KAAK,CAACI,CAAC,GAAG,CAAC,CAAC,CAACI,KAAK,CAAC,IAAI,CAAC,EAAE;QAC1D;QACA;QACA;QACAN,MAAM,CAACI,IAAI,CAACN,KAAK,CAACO,KAAK,CAACJ,WAAW,EAAEC,CAAC,GAAG,CAAC,CAAC,CAAC;QAC5C;QACAA,CAAC,GAAGD,WAAW,GAAGC,CAAC,GAAG,CAAC;QACvB,OAAO,CAACH,EAAE,GAAGD,KAAK,CAACI,CAAC,GAAG,CAAC,CAAC,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACO,KAAK,CAAC,IAAI,CAAC,EAAE;UAC5EJ,CAAC,EAAE;QACP;QACAF,MAAM,CAACI,IAAI,CAACN,KAAK,CAACO,KAAK,CAACJ,WAAW,EAAEC,CAAC,GAAG,CAAC,CAAC,CAAC;QAC5C;QACA;QACA;QACAD,WAAW,GAAGC,CAAC,GAAG,CAAC;MACvB;IACJ;IACA,OAAOF,MAAM;EACjB;AACJ;AACA,OAAO,MAAMO,YAAY,GAAG,IAAIX,YAAY,CAAC,CAAC;AAC9C,OAAO,SAASY,aAAaA,CAACC,MAAM,EAAEC,MAAM,EAAEC,OAAO,EAAE;EACnD,OAAOJ,YAAY,CAACK,IAAI,CAACH,MAAM,EAAEC,MAAM,EAAEC,OAAO,CAAC;AACrD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}