{"ast":null,"code":"export function unixToWin(patch) {\n  if (Array.isArray(patch)) {\n    // It would be cleaner if instead of the line below we could just write\n    //     return patch.map(unixToWin)\n    // but mysteriously TypeScript (v5.7.3 at the time of writing) does not like this and it will\n    // refuse to compile, thinking that unixToWin could then return StructuredPatch[][] and the\n    // result would be incompatible with the overload signatures.\n    // See bug report at https://github.com/microsoft/TypeScript/issues/61398.\n    return patch.map(p => unixToWin(p));\n  }\n  return Object.assign(Object.assign({}, patch), {\n    hunks: patch.hunks.map(hunk => Object.assign(Object.assign({}, hunk), {\n      lines: hunk.lines.map((line, i) => {\n        var _a;\n        return line.startsWith('\\\\') || line.endsWith('\\r') || ((_a = hunk.lines[i + 1]) === null || _a === void 0 ? void 0 : _a.startsWith('\\\\')) ? line : line + '\\r';\n      })\n    }))\n  });\n}\nexport function winToUnix(patch) {\n  if (Array.isArray(patch)) {\n    // (See comment above equivalent line in unixToWin)\n    return patch.map(p => winToUnix(p));\n  }\n  return Object.assign(Object.assign({}, patch), {\n    hunks: patch.hunks.map(hunk => Object.assign(Object.assign({}, hunk), {\n      lines: hunk.lines.map(line => line.endsWith('\\r') ? line.substring(0, line.length - 1) : line)\n    }))\n  });\n}\n/**\n * Returns true if the patch consistently uses Unix line endings (or only involves one line and has\n * no line endings).\n */\nexport function isUnix(patch) {\n  if (!Array.isArray(patch)) {\n    patch = [patch];\n  }\n  return !patch.some(index => index.hunks.some(hunk => hunk.lines.some(line => !line.startsWith('\\\\') && line.endsWith('\\r'))));\n}\n/**\n * Returns true if the patch uses Windows line endings and only Windows line endings.\n */\nexport function isWin(patch) {\n  if (!Array.isArray(patch)) {\n    patch = [patch];\n  }\n  return patch.some(index => index.hunks.some(hunk => hunk.lines.some(line => line.endsWith('\\r')))) && patch.every(index => index.hunks.every(hunk => hunk.lines.every((line, i) => {\n    var _a;\n    return line.startsWith('\\\\') || line.endsWith('\\r') || ((_a = hunk.lines[i + 1]) === null || _a === void 0 ? void 0 : _a.startsWith('\\\\'));\n  })));\n}","map":{"version":3,"names":["unixToWin","patch","Array","isArray","map","p","Object","assign","hunks","hunk","lines","line","i","_a","startsWith","endsWith","winToUnix","substring","length","isUnix","some","index","isWin","every"],"sources":["/Users/elias/Documents/Trabajo/Pruebas-del-IMSS/Simulacion/frontend/node_modules/diff/libesm/patch/line-endings.js"],"sourcesContent":["export function unixToWin(patch) {\n    if (Array.isArray(patch)) {\n        // It would be cleaner if instead of the line below we could just write\n        //     return patch.map(unixToWin)\n        // but mysteriously TypeScript (v5.7.3 at the time of writing) does not like this and it will\n        // refuse to compile, thinking that unixToWin could then return StructuredPatch[][] and the\n        // result would be incompatible with the overload signatures.\n        // See bug report at https://github.com/microsoft/TypeScript/issues/61398.\n        return patch.map(p => unixToWin(p));\n    }\n    return Object.assign(Object.assign({}, patch), { hunks: patch.hunks.map(hunk => (Object.assign(Object.assign({}, hunk), { lines: hunk.lines.map((line, i) => {\n                var _a;\n                return (line.startsWith('\\\\') || line.endsWith('\\r') || ((_a = hunk.lines[i + 1]) === null || _a === void 0 ? void 0 : _a.startsWith('\\\\')))\n                    ? line\n                    : line + '\\r';\n            }) }))) });\n}\nexport function winToUnix(patch) {\n    if (Array.isArray(patch)) {\n        // (See comment above equivalent line in unixToWin)\n        return patch.map(p => winToUnix(p));\n    }\n    return Object.assign(Object.assign({}, patch), { hunks: patch.hunks.map(hunk => (Object.assign(Object.assign({}, hunk), { lines: hunk.lines.map(line => line.endsWith('\\r') ? line.substring(0, line.length - 1) : line) }))) });\n}\n/**\n * Returns true if the patch consistently uses Unix line endings (or only involves one line and has\n * no line endings).\n */\nexport function isUnix(patch) {\n    if (!Array.isArray(patch)) {\n        patch = [patch];\n    }\n    return !patch.some(index => index.hunks.some(hunk => hunk.lines.some(line => !line.startsWith('\\\\') && line.endsWith('\\r'))));\n}\n/**\n * Returns true if the patch uses Windows line endings and only Windows line endings.\n */\nexport function isWin(patch) {\n    if (!Array.isArray(patch)) {\n        patch = [patch];\n    }\n    return patch.some(index => index.hunks.some(hunk => hunk.lines.some(line => line.endsWith('\\r'))))\n        && patch.every(index => index.hunks.every(hunk => hunk.lines.every((line, i) => { var _a; return line.startsWith('\\\\') || line.endsWith('\\r') || ((_a = hunk.lines[i + 1]) === null || _a === void 0 ? void 0 : _a.startsWith('\\\\')); })));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}